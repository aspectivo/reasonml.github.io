<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Records · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="_Quick overview: [Records](/docs/en/overview#records)_"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Records · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="_Quick overview: [Records](/docs/en/overview#records)_"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/en/what-and-why" target="_self">Docs</a></li><li class=""><a href="/en/try" target="_self">Try</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/en/community" target="_self">Community</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/record">日本語</a></li><li><a href="/docs/de/record">Deutsch</a></li><li><a href="/docs/es-ES/record">Español</a></li><li><a href="/docs/fr/record">Français</a></li><li><a href="/docs/ko/record">한국어</a></li><li><a href="/docs/pt-BR/record">Português (Brasil)</a></li><li><a href="/docs/ru/record">Русский</a></li><li><a href="/docs/uk/record">Українська</a></li><li><a href="/docs/zh-CN/record">中文</a></li><li><a href="/docs/zh-TW/record">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Language Basics</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/what-and-why">What &amp; Why</a></li><li class="navListItem"><a class="navItem" href="/docs/en/getting-started">Getting started</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/en/editor-plugins">Editor Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/en/refmt">Format (refmt)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Language Basics</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/en/let-binding">Let Bindings</a></li><li class="navListItem"><a class="navItem" href="/docs/en/primitives">Primitives</a></li><li class="navListItem"><a class="navItem" href="/docs/en/basic-structures">Basic Structures</a></li><li class="navListItem"><a class="navItem" href="/docs/en/type">Types</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/en/record">Records</a></li><li class="navListItem"><a class="navItem" href="/docs/en/variant">Variants</a></li><li class="navListItem"><a class="navItem" href="/docs/en/option">Options and nullability</a></li><li class="navListItem"><a class="navItem" href="/docs/en/function">Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/en/recursion">Recursion</a></li><li class="navListItem"><a class="navItem" href="/docs/en/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/en/pattern-matching">Pattern Matching</a></li><li class="navListItem"><a class="navItem" href="/docs/en/mutable-bindings">Mutable Bindings</a></li><li class="navListItem"><a class="navItem" href="/docs/en/loops">Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/en/module">Modules</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Advanced Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/en/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/en/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/en/object">Object</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/compiling-to-js-with-melange">Melange</a></li><li class="navListItem"><a class="navItem" href="/docs/en/interop">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/en/syntax-cheatsheet">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/en/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/en/promise">Promise</a></li><li class="navListItem"><a class="navItem" href="/docs/en/libraries">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/en/converting-from-js">Converting from JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/faq">Frequently Asked Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/en/extra-goodies">Extra Goodies</a></li><li class="navListItem"><a class="navItem" href="/docs/en/rtop">REPL (rtop)</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/reasonml/reasonml.github.io/tree/source/docs/record.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">Records</h1></header><article><div><span><p><em>Quick overview: <a href="/docs/en/overview#records">Records</a></em></p>
<p>Records are structures used for storing data in named fields. They are similar
to objects or structs in other languages. Records are very performant and can be
used in hot code paths.</p>
<p><em>Note: Record types are <a href="https://en.wikipedia.org/wiki/Nominal_type_system">nominal</a>. This has some important consequences
that we will explore <a href="#nominal-typing">later on</a>.</em></p>
<h2><a class="anchor" aria-hidden="true" id="defining-a-record"></a><a href="#defining-a-record" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining a Record</h2>
<p>In order to use a record, you must first declare a type for it:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {
  name: string,
  age: int,
};
</code></pre>
<p>From this point on the <code>person</code> record can be created and the correct type will
be inferred. It does not have to be annotated:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> alice = {
  name: <span class="hljs-string">"Alice"</span>,
  age: <span class="hljs-number">42</span>,
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="accessing-fields"></a><a href="#accessing-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessing Fields</h2>
<p>Access fields on a record by using a <code>.</code> followed by the field name:</p>
<pre><code class="hljs css language-reason">print_endline(<span class="hljs-string">"Hello "</span> <span class="hljs-operator">++</span> alice.name);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="updating-records-spreading"></a><a href="#updating-records-spreading" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Updating Records &amp; Spreading</h2>
<p>Record fields are <strong>immutable</strong> by default and cannot be changed. To &quot;update&quot;
a record, you will typically start with some existing record and use the spread
syntax to update the desired set of fields:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> happyBirthday = (person) =&gt; {
  {<span class="hljs-operator">...</span>person, age: person.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>};
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="mutable-records"></a><a href="#mutable-records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutable Records</h2>
<p>Records do support mutable fields, and this is how <a href="/docs/en/overview#refs">Mutable Bindings</a>
are implemented:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> mutablePerson = {
  name: string,
  <span class="hljs-keyword">mutable</span> age: int,
};

<span class="hljs-keyword">let</span> happyBirthday = (person) =&gt; {
  person.age = person.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="nominal-typing"></a><a href="#nominal-typing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nominal Typing</h2>
<p>Records use nominal typing, which means that only records that have exactly
the same type are compatible with each other. Two different record types with
the exact same fields cannot be used in place of one another.</p>
<p>This comes up most often when trying to spread one record that has a subset
of fields into another record:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> baby = {
  name: string,
  age: int,
};

<span class="hljs-keyword">type</span> adult = {
  name: string,
  age: int,
  job: string,
};

<span class="hljs-keyword">let</span> hire = (baby: baby, job): adult =&gt; {
  <span class="hljs-comment">/* Error: Unexpected type */</span>
  {<span class="hljs-operator">...</span>baby, job: job};
};
</code></pre>
<p>Instead, the conversion has to be done manually and cover all fields:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> hire = (baby: baby, job): adult =&gt; {
  {
    name: baby.name,
    age: baby.age,
    job: job,
  };
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="tips"></a><a href="#tips" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips</h2>
<h3><a class="anchor" aria-hidden="true" id="shorthand-notation"></a><a href="#shorthand-notation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Shorthand Notation</h3>
<p>Fields of records are often constructed using bindings with the exact
same name. A shorthand notation can be used:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> name = <span class="hljs-string">"Alice"</span>;
<span class="hljs-keyword">let</span> age = <span class="hljs-number">42</span>;

<span class="hljs-comment">/* With shorthand */</span>
<span class="hljs-keyword">let</span> alice = {name, age};

<span class="hljs-comment">/* Without shorthand */</span>
<span class="hljs-keyword">let</span> alice = {name: name, age: age};
</code></pre>
<p><em>Warning: There is a &quot;gotcha&quot; when working with only one field, see
<a href="#single-field-records">Single Field Records</a> below.</em></p>
<h3><a class="anchor" aria-hidden="true" id="providing-all-fields"></a><a href="#providing-all-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Providing All Fields</h3>
<p>When working with large records it can be annoying to provide all fields when
there are sensible defaults. Two ways to work around this are by using a default
record everywhere:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> defaultPerson = {
  name: <span class="hljs-string">"Unknown"</span>,
  age: <span class="hljs-number">0</span>,
};

<span class="hljs-keyword">let</span> alice = {
  <span class="hljs-operator">...</span>defaultPerson,
  name: <span class="hljs-string">"Alice"</span>,
};
</code></pre>
<p>Or by creating a builder function:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> makePerson = (
  ~name=<span class="hljs-string">"Unknown"</span>,
  ~age=<span class="hljs-number">0</span>,
  (),
) =&gt; {
  {name, age};
};

<span class="hljs-comment">/* The final unit is important. It lets the compiler know you're "done". */</span>
<span class="hljs-keyword">let</span> alice = makePerson(~name=<span class="hljs-string">"Alice"</span>, ());
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="troubleshooting"></a><a href="#troubleshooting" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Troubleshooting</h2>
<h3><a class="anchor" aria-hidden="true" id="add-an-explicit-annotation"></a><a href="#add-an-explicit-annotation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Add an Explicit Annotation</h3>
<p>There are quite a few different issues that can come up when using records and
it can feel like you are fighting the type system. A general approach to
figuring out what the type system wants you to do is to add explicit annotations
and see if that fixes, moves, or changes the error.</p>
<p>This approach can be used to fix or diagnose all of the following issues.</p>
<h3><a class="anchor" aria-hidden="true" id="unbound-record-field"></a><a href="#unbound-record-field" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unbound Record Field</h3>
<p>The record type must be in scope to build records of that type; otherwise, there
will be an &quot;Unbound Record Field&quot; error.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Person</span> = {
  <span class="hljs-keyword">type</span> t = {
    name: string,
    age: int,
  };
};

<span class="hljs-keyword">let</span> alice = {
  <span class="hljs-comment">/* Error: Unbound record field */</span>
  name: <span class="hljs-string">"Alice"</span>,
  age: <span class="hljs-number">42</span>,
};
</code></pre>
<p>Fix this by adding an explicit type:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> alice: <span class="hljs-module-identifier">Person</span>.t = {
  name: <span class="hljs-string">"Alice"</span>,
  age: <span class="hljs-number">42</span>,
};
</code></pre>
<p>Or by opening the module:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">open</span> <span class="hljs-module-identifier">Person</span>;

<span class="hljs-keyword">let</span> alice = {
  name: <span class="hljs-string">"Alice"</span>,
  age: <span class="hljs-number">42</span>,
};
</code></pre>
<p>There is also an odd syntax that you might come across when working with records
with the type out of scope. Fields can be referenced by <code>Module.field</code> instead
of just <code>.field</code>. This is discouraged in favor of the prior approaches, but is
something to be aware of:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> alice = {
  <span class="hljs-module-identifier">Person</span>.name: <span class="hljs-string">"Alice"</span>,
  <span class="hljs-module-identifier">Person</span>.age: <span class="hljs-number">42</span>,
};

<span class="hljs-keyword">let</span> getName = (person) =&gt; {
  person.<span class="hljs-module-identifier">Person</span>.name;
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="disambiguating-record-types"></a><a href="#disambiguating-record-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Disambiguating Record Types</h3>
<p>If records have any field names in common the type system can get confused. The
type inference will pick one of the types that matches the first field it sees
and use that as the type, even if later fields are incompatible.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {
  age: int,
  name: string,
};

<span class="hljs-keyword">type</span> wine = {
  age: int,
  kind: string,
};

<span class="hljs-keyword">let</span> happyBirthday = person =&gt; {
  <span class="hljs-keyword">let</span> next = {<span class="hljs-operator">...</span>person, age: person.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>};
  <span class="hljs-comment">/* Error: The field name does not belong to type wine */</span>
  print_endline(<span class="hljs-string">"Happy Birthday "</span> <span class="hljs-operator">++</span> person.name);
  next;
};
</code></pre>
<p>Fix this by adding an explicit type:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> happyBirthday = (person: person) =&gt; {
  <span class="hljs-keyword">let</span> next = {<span class="hljs-operator">...</span>person, age: person.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>};
  print_endline(<span class="hljs-string">"Happy Birthday "</span> <span class="hljs-operator">++</span> person.name);
  next;
};
</code></pre>
<p>Or, a less reliable fix is to reorder the usage of fields so an unambiguous
field is seen first:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> happyBirthday = (person) =&gt; {
  print_endline(<span class="hljs-string">"Happy Birthday "</span> <span class="hljs-operator">++</span> person.name);
  <span class="hljs-keyword">let</span> next = {<span class="hljs-operator">...</span>person, age: person.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>};
  next;
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="single-field-records"></a><a href="#single-field-records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Single Field Records</h3>
<p>There is an uncommon edge-case when using <a href="#shorthand-notation">Shorthand Notation</a>
with records containing only one field. In the following example, taking into
account shorthand notation, try to determine:</p>
<ul>
<li>Does the function return a person with the name field set as name?</li>
<li>Does the function return the name argument?</li>
</ul>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {
  name: string,
};

<span class="hljs-keyword">let</span> fn = (name) =&gt; {
  name
};
</code></pre>
<p>If single-field records are allowed to use shorthand notation this is ambiguous.
That is not okay in a language! To avoid this ambiguity single-field records
always have to have both field and value written:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> fnName = (name): string =&gt; {
  name
};

<span class="hljs-keyword">let</span> fnPerson = (name): person =&gt; {
  name: name
};
</code></pre>
<p>This is an uncommon case because single-field records are uncommon. Typically
instead of having a record type you would use the type of the single field
directly (a notable exception is the <a href="/docs/en/overview#refs"><code>ref</code> record type</a>).</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/en/type"><span class="arrow-prev">← </span><span>Types</span></a><a class="docs-next button" href="/docs/en/variant"><span>Variants</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#defining-a-record">Defining a Record</a></li><li><a href="#accessing-fields">Accessing Fields</a></li><li><a href="#updating-records-amp-spreading">Updating Records &amp; Spreading</a></li><li><a href="#mutable-records">Mutable Records</a></li><li><a href="#nominal-typing">Nominal Typing</a></li><li><a href="#tips">Tips</a><ul class="toc-headings"><li><a href="#shorthand-notation">Shorthand Notation</a></li><li><a href="#providing-all-fields">Providing All Fields</a></li></ul></li><li><a href="#troubleshooting">Troubleshooting</a><ul class="toc-headings"><li><a href="#add-an-explicit-annotation">Add an Explicit Annotation</a></li><li><a href="#unbound-record-field">Unbound Record Field</a></li><li><a href="#disambiguating-record-types">Disambiguating Record Types</a></li><li><a href="#single-field-records">Single Field Records</a></li></ul></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:en"]}
              });
            </script></body></html>